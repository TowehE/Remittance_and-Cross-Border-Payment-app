import { prisma } from './prisma'; // adjust import as needed
import { transaction_queue } from './queues'; // your Bull queue instance

async function schedule_transaction_jobs() {
  try {
    const now = new Date();
    const tenMinutesAgo = new Date(now.getTime() - 10 * 60 * 1000);

    // Fetch pending transactions, limit to 20 for manageable batch size
    const pendingTransactions = await prisma.transaction.findMany({
      where: {
        status: 'PENDING',
      },
      take: 20,
      orderBy: { createdAt: 'asc' },
    });

    console.log(`Found ${pendingTransactions.length} pending transactions`);

    for (const transaction of pendingTransactions) {
      if (transaction.createdAt < tenMinutesAgo) {
        // Older than 10 minutes — schedule auto-cancel job
        await transaction_queue.add(
          'auto-cancel',
          { transactionId: transaction.id },
          {
            attempts: 3,
            removeOnComplete: true,
            removeOnFail: false,
          }
        );
        console.log(`Added auto-cancel job for transaction ${transaction.id}`);
      } else {
        // Newer than 10 minutes — schedule process-transaction job
        await transaction_queue.add(
          'process-transaction',
          { transactionId: transaction.id },
          {
            attempts: 5,
            backoff: { type: 'exponential', delay: 2000 },
            removeOnComplete: true,
            removeOnFail: false,
          }
        );
        console.log(`Added process-transaction job for transaction ${transaction.id}`);
      }
    }

    console.log('All transaction jobs scheduled');
  } catch (error) {
    console.error('Error scheduling transaction jobs:', error);
  }
}

const tenMinutesAgo = new Date(Date.now() - 10 * 60 * 1000);
        

async function schedule_pending_transactions() {
    try {
        // Get some of the pending transactions from database
        const pending_transactions = await prisma.transaction.findMany({
            where: {
                 status: 'PENDING',
                 createdAt: { lt: new Date(), gte: tenMinutesAgo }
                },
            
            take: 10
        });
        console.log(`Found ${pending_transactions.length} pending transactions`);

        
        // Adding them to the queue
        for (const transaction of pending_transactions) {
            const job = await transaction_queue.add('process-transaction', {
                transactionId: transaction.id
                    }, {
            attempts: 5,
            backoff: { type: 'exponential', delay: 2000 },
            removeOnComplete: true,
            removeOnFail: false,
            });
            console.log(`Added job ${job.id} for transaction: ${transaction.id}`);
        }
        


        console.log('All jobs added to queue');
    } catch (error) {
        console.error('Error testing queue:', error);
    }
}


// Schedule only transactions that are older than 10 minutes and still PENDING
async function schedule_auto_cancel_jobs() {
  const threshold = new Date(Date.now() - 10 * 60 * 1000);

  const stale_transactions = await prisma.transaction.findMany({
    where: {
      status: TransactionStatus.PENDING,
      createdAt: { lt: threshold },
    },
    take: 5,
  });
 console.log(`Found ${stale_transactions.length} stale transactions to schedule for auto-cancel.`);

 for (const tx of stale_transactions) {
        await transaction_queue.add('auto-cancel', { 
            transactionId: tx.id 
        }, {
            attempts: 3,
            removeOnComplete: true,
            removeOnFail: false,
        });
        console.log(`Added auto-cancel job for stale transaction: ${tx.id}`);
    }
}

export function start_scheduled_jobs() {
  schedule_pending_transactions();
  schedule_auto_cancel_jobs();

  setInterval(schedule_pending_transactions, 5 * 60 * 1000);
  setInterval(schedule_auto_cancel_jobs, 5 * 60 * 1000);
}











import { PrismaClient, TransactionStatus } from "@prisma/client";
import { transaction_queue } from "../rate/redis.service";
import { get_transaction_with_users, mark_transaction_as_failed } from "./transaction.crud.queue";
import { process_successful_payment } from "../payment/payment.service";
import Decimal from "decimal.js";

const prisma = new PrismaClient();

transaction_queue.process("process-transaction", async (job) => {
  const { transactionId } = job.data;
  console.log(`Processing transaction: ${transactionId}`);

  try {
    const transaction = await prisma.transaction.findUnique({
      where: { id: transactionId },
    });

    if (!transaction) {
         throw new Error(`Transaction ${transactionId} not found`);
       }
   
       if (transaction.status !== TransactionStatus.PENDING) {
         console.log(`Transaction ${transactionId} is not pending. Current status: ${transaction.status}`);
         return;
       }
          const tenMinutesAgo = new Date(Date.now() - 10 * 60 * 1000);
    if (transaction.createdAt < tenMinutesAgo) {
      await prisma.transaction.update({
        where: { id: transactionId },
        data: { status: TransactionStatus.CANCELLED },
      });
      console.log(`Transaction ${transactionId} cancelled due to expiration`);
      return;
    }

 
    const locked = await prisma.transaction.updateMany({
      where: {
        id: transactionId,
        status: TransactionStatus.PENDING,
      },
      data: {
        status: TransactionStatus.PROCESSING,
      },
    });

    if (locked.count === 0) {
      console.log(`Transaction ${transactionId} already picked`);
      return;
    }

    
    const fullTransaction = await get_transaction_with_users(transactionId);
    if (!fullTransaction) throw new Error("Transaction with users not found");

    const senderAccount = fullTransaction.sender?.accounts.find(
      (acc) => acc.currency === fullTransaction.sourceCurrency
    );

    if (!senderAccount) {
      await mark_transaction_as_failed(transactionId, "Sender account not found");
      return;
    }

    const senderBalance = new Decimal(senderAccount.balance);
    const amount = new Decimal(fullTransaction.sourceAmount);

    if (senderBalance.lessThan(amount)) {
      await mark_transaction_as_failed(transactionId, "Insufficient funds");
      return;
    }

    // Step 5: Process
    await process_successful_payment({ id: transactionId });

  } catch (error: any) {
    console.error(`Failed to process transaction ${transactionId}:`, error);
    await mark_transaction_as_failed(transactionId, error.message || "Unknown error");
    throw error;
  }
});


